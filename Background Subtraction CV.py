# -*- coding: utf-8 -*-
"""b1_10_Niharika_Nashine_prac9_cv.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18Iw2I3o0bGJuoug69jyNguWQkaDXzD0C
"""



"""Name:Niharika Nashine

Roll no:10

Batch=B1

AIM: to perform Background subtracting using diffrent algorithms in image as well as videos

"""

import numpy as np
import cv2
import matplotlib.pyplot as plt

image=cv2.imread("bottle_n.jpg")
image=cv2.resize(image,(500,500))
image_rgb=cv2.cvtColor(image,cv2.COLOR_BGR2RGB)
plt.imshow(image_rgb)
plt.show()

import numpy as np
import cv2
import matplotlib.pyplot as plt

image=cv2.imread("bottle_n.jpg")
image=cv2.resize(image,(500,500))
image_rgb=cv2.cvtColor(image,cv2.COLOR_BGR2RGB)
mask=numpy.zeros(image.shape[:2],dtype="uint8")

bgModel=np.zeros((1,65),np.float64)
fgModel=np.zeros((1,65),np.float64)

height,width=image.shape[:2]
rect=(15,15,width-20,height-20)

cv2.grabCut(image,mask,rect,bgModel,fgModel,5,cv2.GC_INIT_WITH_RECT)
mask_binary=np.where((mask==2)|(mask==0),0,1).astype('uint8')
foreground=image*mask_binary[:,:,np.newaxis]
foreground_rgb=cv2.cvtColor(foreground,cv2.COLOR_BGR2RGB)
plt.subplot(1,2,1)
plt.imshow(image_rgb)
plt.subplot(1,2,2)
plt.imshow(foreground_rgb)
plt.show()



"""with rect=(15,15,width-50,height-20)"""

import numpy as np
import cv2
import matplotlib.pyplot as plt

image=cv2.imread("bottle_n.jpg")
image=cv2.resize(image,(500,500))
image_rgb=cv2.cvtColor(image,cv2.COLOR_BGR2RGB)
mask=numpy.zeros(image.shape[:2],dtype="uint8")

bgModel=np.zeros((1,65),np.float64)
fgModel=np.zeros((1,65),np.float64)

height,width=image.shape[:2]
rect=(15,15,width-50,height-20)

cv2.grabCut(image,mask,rect,bgModel,fgModel,5,cv2.GC_INIT_WITH_RECT)
mask_binary=np.where((mask==2)|(mask==0),0,1).astype('uint8')
foreground=image*mask_binary[:,:,np.newaxis]
foreground_rgb=cv2.cvtColor(foreground,cv2.COLOR_BGR2RGB)
plt.subplot(1,2,1)
plt.imshow(image_rgb)
plt.subplot(1,2,2)
plt.imshow(foreground_rgb)
plt.show()

"""rect=(25,15,width-20,height-20)"""

import numpy as np
import cv2
import matplotlib.pyplot as plt

image=cv2.imread("bottle_n.jpg")
image=cv2.resize(image,(500,500))
image_rgb=cv2.cvtColor(image,cv2.COLOR_BGR2RGB)
mask=numpy.zeros(image.shape[:2],dtype="uint8")

bgModel=np.zeros((1,65),np.float64)
fgModel=np.zeros((1,65),np.float64)

height,width=image.shape[:2]
rect=(25,15,width-20,height-20)

cv2.grabCut(image,mask,rect,bgModel,fgModel,5,cv2.GC_INIT_WITH_RECT)
mask_binary=np.where((mask==2)|(mask==0),0,1).astype('uint8')
foreground=image*mask_binary[:,:,np.newaxis]
foreground_rgb=cv2.cvtColor(foreground,cv2.COLOR_BGR2RGB)
plt.subplot(1,2,1)
plt.imshow(image_rgb)
plt.subplot(1,2,2)
plt.imshow(foreground_rgb)
plt.show()

import numpy as np
import cv2
import matplotlib.pyplot as plt

image=cv2.imread("bottle_n.jpg")
image=cv2.resize(image,(500,500))
image_rgb=cv2.cvtColor(image,cv2.COLOR_BGR2RGB)
mask=numpy.zeros(image.shape[:2],dtype="uint8")

bgModel=np.zeros((1,65),np.float64)
fgModel=np.zeros((1,65),np.float64)

height,width=image.shape[:2]
rect = (20, 50, 1496, 1948)

cv2.grabCut(image,mask,rect,bgModel,fgModel,5,cv2.GC_INIT_WITH_RECT)
mask_binary=np.where((mask==2)|(mask==0),0,1).astype('uint8')
foreground=image*mask_binary[:,:,np.newaxis]
foreground_rgb=cv2.cvtColor(foreground,cv2.COLOR_BGR2RGB)
plt.subplot(1,2,1)
plt.imshow(image_rgb)
plt.subplot(1,2,2)
plt.imshow(foreground_rgb)
plt.show()

import numpy as np
import cv2
import matplotlib.pyplot as plt

image=cv2.imread("bottle_n.jpg")
image=cv2.resize(image,(500,500))
image_rgb=cv2.cvtColor(image,cv2.COLOR_BGR2RGB)
mask=numpy.zeros(image.shape[:2],dtype="uint8")

bgModel=np.zeros((1,65),np.float64)
fgModel=np.zeros((1,65),np.float64)

height,width=image.shape[:2]
rect = (100, 50, 1496, 1948)

cv2.grabCut(image,mask,rect,bgModel,fgModel,5,cv2.GC_INIT_WITH_RECT)
mask_binary=np.where((mask==2)|(mask==0),0,1).astype('uint8')
foreground=image*mask_binary[:,:,np.newaxis]
foreground_rgb=cv2.cvtColor(foreground,cv2.COLOR_BGR2RGB)
plt.subplot(1,2,1)
plt.imshow(image_rgb)
plt.subplot(1,2,2)
plt.imshow(foreground_rgb)
plt.show()

"""got my best accuracy here
when rect is rect = (100, 50, width-200, height-20)
"""

import numpy as np
import cv2
import matplotlib.pyplot as plt

image=cv2.imread("bottle_n.jpg")
image=cv2.resize(image,(500,500))
image_rgb=cv2.cvtColor(image,cv2.COLOR_BGR2RGB)
mask=numpy.zeros(image.shape[:2],dtype="uint8")

bgModel=np.zeros((1,65),np.float64)
fgModel=np.zeros((1,65),np.float64)

height,width=image.shape[:2]
rect = (100, 50, width-200, height-20)

cv2.grabCut(image,mask,rect,bgModel,fgModel,5,cv2.GC_INIT_WITH_RECT)
mask_binary=np.where((mask==2)|(mask==0),0,1).astype('uint8')
foreground=image*mask_binary[:,:,np.newaxis]
foreground_rgb=cv2.cvtColor(foreground,cv2.COLOR_BGR2RGB)
plt.subplot(1,2,1)
plt.imshow(image_rgb)
plt.subplot(1,2,2)
plt.imshow(foreground_rgb)
plt.show()

import numpy as np
import cv2
import matplotlib.pyplot as plt

image=cv2.imread("bottle_n.jpg")
image=cv2.resize(image,(500,500))
image_rgb=cv2.cvtColor(image,cv2.COLOR_BGR2RGB)
mask=numpy.zeros(image.shape[:2],dtype="uint8")

bgModel=np.zeros((1,65),np.float64)
fgModel=np.zeros((1,65),np.float64)

height,width=image.shape[:2]
rect = (100, 50, width-200, height-70)

cv2.grabCut(image,mask,rect,bgModel,fgModel,5,cv2.GC_INIT_WITH_RECT)
mask_binary=np.where((mask==2)|(mask==0),0,1).astype('uint8')
foreground=image*mask_binary[:,:,np.newaxis]
foreground_rgb=cv2.cvtColor(foreground,cv2.COLOR_BGR2RGB)
plt.subplot(1,2,1)
plt.imshow(image_rgb)
plt.subplot(1,2,2)
plt.imshow(foreground_rgb)
plt.show()

#Grayscale conversion, Gaussian blur, thresholding, morphological operations, bitwise AND for foreground extraction
import cv2
import numpy as np
import matplotlib.pyplot as plt
from google.colab import files



# Make sure the file you uploaded is correctly named
image = cv2.imread("bottle_n.jpg")  # Replace with your actual image filename

# Check if the image is loaded properly
if image is None:
    print("Error: Image not found or could not be loaded.")
else:
    # Convert to grayscale (if the image is in color)
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Apply Gaussian blur to reduce noise and improve background subtraction
    blurred = cv2.GaussianBlur(gray, (5, 5), 0)

    # Manually threshold the image to create a mask based on pixel intensity
    _, fgmask = cv2.threshold(blurred, 120, 255, cv2.THRESH_BINARY)

    # Apply morphological operations to clean up the mask (remove small noise)
    kernel = np.ones((5, 5), np.uint8)
    fgmask = cv2.morphologyEx(fgmask, cv2.MORPH_OPEN, kernel)
    fgmask = cv2.morphologyEx(fgmask, cv2.MORPH_DILATE, kernel)

    # Make a new image where the background is black and the foreground remains
    foreground = cv2.bitwise_and(image, image, mask=fgmask)

    # Create a black image (background)
    black_background = np.zeros_like(image)

    # Combine the black background with the extracted foreground
    result = cv2.add(foreground, black_background)

    # Convert images from BGR to RGB for displaying with matplotlib
    image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
    fgmask_rgb = cv2.cvtColor(fgmask, cv2.COLOR_GRAY2RGB)
    result_rgb = cv2.cvtColor(result, cv2.COLOR_BGR2RGB)

    # Plot the images using matplotlib
    plt.figure(figsize=(12, 4))

    # Display original image
    plt.subplot(1, 3, 1)
    plt.imshow(image_rgb)
    plt.title('Original Image')
    plt.axis('off')  # Hide axes

    # Display foreground mask
    plt.subplot(1, 3, 2)
    plt.imshow(fgmask_rgb)
    plt.title('Foreground Mask')
    plt.axis('off')

    # Display final result with black background
    plt.subplot(1, 3, 3)
    plt.imshow(result_rgb)
    plt.title('Foreground with Black Background')
    plt.axis('off')

    # Show the plot
    plt.tight_layout()
    plt.show()



import cv2
import numpy as np
import matplotlib.pyplot as plt

# Load image
image_path = "bottle_n.jpg"  # Change this to your image path
frame = cv2.imread(image_path)
frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)  # Convert to RGB for plt

# Create Background Subtractor
fgbg = cv2.createBackgroundSubtractorMOG2()

# Apply background subtraction
fgmask = fgbg.apply(frame)

# Convert mask to 3 channels
fgmask_3ch = cv2.cvtColor(fgmask, cv2.COLOR_GRAY2BGR)

# Make background black by applying mask
result = cv2.bitwise_and(frame, fgmask_3ch)
result_rgb = cv2.cvtColor(result, cv2.COLOR_BGR2RGB)  # Convert back to RGB for plt
# Display result using matplotlib
plt.subplot(1, 2, 1)
plt.imshow(frame_rgb)
plt.title('Original Image')
plt.axis('off')

plt.subplot(1, 2, 2)
plt.imshow(result)

plt.axis('off')  # Hide axes
plt.show()

#frame diffrence


import cv2
import numpy as np
import matplotlib.pyplot as plt

# Load two consecutive images
image_path1 = 'tp1.jpg'  # Change this to your first image path
image_path2 = 'tp2.jpg'  # Change this to your second image path
frame1 = cv2.imread(image_path1)
frame2 = cv2.imread(image_path2)

# Check if the images were loaded correctly
if frame1 is None or frame2 is None:
    raise FileNotFoundError("Error: One or both image paths are incorrect. Check the paths and try again.")

frame1 = cv2.cvtColor(frame1, cv2.COLOR_BGR2RGB)  # Convert to RGB for plt
frame2 = cv2.cvtColor(frame2, cv2.COLOR_BGR2RGB)  # Convert to RGB for plt

# Compute frame difference
diff = cv2.absdiff(frame1, frame2)

# Convert difference to grayscale and threshold
gray_diff = cv2.cvtColor(diff, cv2.COLOR_RGB2GRAY)
_, fgmask = cv2.threshold(gray_diff, 50, 255, cv2.THRESH_BINARY)

# Convert mask to 3 channels
fgmask_3ch = cv2.cvtColor(fgmask, cv2.COLOR_GRAY2BGR)

# Keep original colors for foreground and set background to black
result = cv2.bitwise_and(frame1, fgmask_3ch)

# Display original images and frame difference using subplots
fig, ax = plt.subplots(1, 3, figsize=(15, 5))
ax[0].imshow(frame1)
ax[0].set_title("First Image")
ax[0].axis('off')
ax[1].imshow(frame2)
ax[1].set_title("Second Image")
ax[1].axis('off')
ax[2].imshow(result)
ax[2].set_title("Frame Difference")
ax[2].axis('off')
plt.show()

import cv2
import numpy as np
import matplotlib.pyplot as plt

# Load two consecutive images
image_path1 = 'tp2.jpg'  # Change this to your first image path
image_path2 = 'tp1.jpg'  # Change this to your second image path
frame1 = cv2.imread(image_path1)
frame2 = cv2.imread(image_path2)

# Check if the images were loaded correctly
if frame1 is None or frame2 is None:
    raise FileNotFoundError("Error: One or both image paths are incorrect. Check the paths and try again.")

frame1 = cv2.cvtColor(frame1, cv2.COLOR_BGR2RGB)  # Convert to RGB for plt
frame2 = cv2.cvtColor(frame2, cv2.COLOR_BGR2RGB)  # Convert to RGB for plt

# Compute frame difference
diff = cv2.absdiff(frame1, frame2)

# Convert difference to grayscale and threshold
gray_diff = cv2.cvtColor(diff, cv2.COLOR_RGB2GRAY)
_, fgmask = cv2.threshold(gray_diff, 50, 255, cv2.THRESH_BINARY)

# Convert mask to 3 channels
fgmask_3ch = cv2.cvtColor(fgmask, cv2.COLOR_GRAY2BGR)

# Keep original colors for foreground and set background to black
result = cv2.bitwise_and(frame1, fgmask_3ch)

# Display original images and frame difference using subplots
fig, ax = plt.subplots(1, 3, figsize=(15, 5))
ax[0].imshow(frame1)
ax[0].set_title("First Image")
ax[0].axis('off')
ax[1].imshow(frame2)
ax[1].set_title("Second Image")
ax[1].axis('off')
ax[2].imshow(result)
ax[2].set_title("Frame Difference")
ax[2].axis('off')
plt.show()

"""#for video using frame diffrence"""

#for video
import cv2
import numpy as np
import matplotlib.pyplot as plt

# Load video
video_path = 'inh.mp4'  # Change this to your video path
cap = cv2.VideoCapture(video_path)

# Check if the video was loaded correctly
if not cap.isOpened():
    raise FileNotFoundError("Error: Video file not found. Check the path and try again.")

ret, prev_frame = cap.read()
if not ret:
    raise RuntimeError("Error: Could not read the first frame from the video.")

prev_frame = cv2.cvtColor(prev_frame, cv2.COLOR_BGR2RGB)

while cap.isOpened():
    ret, frame = cap.read()
    if not ret:
        break

    frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)

    # Compute frame difference
    diff = cv2.absdiff(prev_frame, frame_rgb)

    # Convert difference to grayscale and threshold
    gray_diff = cv2.cvtColor(diff, cv2.COLOR_RGB2GRAY)
    _, fgmask = cv2.threshold(gray_diff, 50, 255, cv2.THRESH_BINARY)

    # Convert mask to 3 channels
    fgmask_3ch = cv2.cvtColor(fgmask, cv2.COLOR_GRAY2BGR)

    # Keep original colors for foreground and set background to black
    result = cv2.bitwise_and(frame_rgb, fgmask_3ch)

    # Display original and processed frame using subplots
    fig, ax = plt.subplots(1, 2, figsize=(10, 5))
    ax[0].imshow(frame_rgb)
    ax[0].set_title("Original Frame")
    ax[0].axis('off')
    ax[1].imshow(result)
    ax[1].set_title("Frame Difference")
    ax[1].axis('off')
    plt.show()

    prev_frame = frame_rgb  # Update previous frame

cap.release()

#for video using frame diffrence
import cv2
import numpy as np
import matplotlib.pyplot as plt

# Load video
video_path = 'case.mp4'  # Change this to your video path
cap = cv2.VideoCapture(video_path)

# Check if the video was loaded correctly
if not cap.isOpened():
    raise FileNotFoundError("Error: Video file not found. Check the path and try again.")

ret, prev_frame = cap.read()
if not ret:
    raise RuntimeError("Error: Could not read the first frame from the video.")

prev_frame = cv2.cvtColor(prev_frame, cv2.COLOR_BGR2RGB)

while cap.isOpened():
    ret, frame = cap.read()
    if not ret:
        break

    frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)

    # Compute frame difference
    diff = cv2.absdiff(prev_frame, frame_rgb)

    # Convert difference to grayscale and threshold
    gray_diff = cv2.cvtColor(diff, cv2.COLOR_RGB2GRAY)
    _, fgmask = cv2.threshold(gray_diff, 50, 255, cv2.THRESH_BINARY)

    # Convert mask to 3 channels
    fgmask_3ch = cv2.cvtColor(fgmask, cv2.COLOR_GRAY2BGR)

    # Keep original colors for foreground and set background to black
    result = cv2.bitwise_and(frame_rgb, fgmask_3ch)

    # Display original and processed frame using subplots
    fig, ax = plt.subplots(1, 2, figsize=(10, 5))
    ax[0].imshow(frame_rgb)
    ax[0].set_title("Original Frame")
    ax[0].axis('off')
    ax[1].imshow(result)
    ax[1].set_title("Frame Difference")
    ax[1].axis('off')
    plt.show()

    prev_frame = frame_rgb  # Update previous frame

cap.release()



"""uding MOG"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

# Load video
video_path = 'case.mp4'  # Change this to your video path
cap = cv2.VideoCapture(video_path)

# Check if the video was loaded correctly
if not cap.isOpened():
    raise FileNotFoundError("Error: Video file not found. Check the path and try again.")

# Create Background Subtractor using MOG2
fgbg = cv2.createBackgroundSubtractorMOG2()

while cap.isOpened():
    ret, frame = cap.read()
    if not ret:
        break

    frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)

    # Apply MOG2 background subtraction
    fgmask = fgbg.apply(frame)

    # Convert mask to 3 channels
    fgmask_3ch = cv2.cvtColor(fgmask, cv2.COLOR_GRAY2BGR)

    # Keep original colors for foreground and set background to black
    result = cv2.bitwise_and(frame_rgb, fgmask_3ch)

    # Display original and processed frame using subplots
    fig, ax = plt.subplots(1, 2, figsize=(10, 5))
    ax[0].imshow(frame_rgb)
    ax[0].set_title("Original Frame")
    ax[0].axis('off')
    ax[1].imshow(result)
    ax[1].set_title("MOG2 Background Subtraction")
    ax[1].axis('off')
    plt.show()

cap.release()

